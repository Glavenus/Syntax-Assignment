/* ifstmt
 Parses strings in the language generated by the rule:
 <ifstmt> -> if (<boolexpr>) <statement>
 [else <statement>]
 */
void ifstmt(void) {
 if (nextToken != IF_CODE)
 	error();
 else {
	lex();
 	if (nextToken != LEFT_PAREN)
 		error();
 	else {
 		lex();
 		boolexpr();
 		if (nextToken != RIGHT_PAREN)
 			error();
 		else {
 			lex();
		 	statement();
 			if (nextToken == ELSE_CODE) {
 				lex();
 				statement();
 			}
 		}
 	}
 }
}

/* whilestmt
 Parses strings in the language generated by the rule:
 <whilestmt> -> while '(' <arithexpr> ')' <statement>
 [else <statement>]
 */

void whilestmt(void) {
    if (nextToken != WHILE_CODE)
        error();
    else {
    lex();
        if (nextToekn != LEFT_PAREN)
        error();
        else {
            lex();
            arithexpr();
        if (nextToken != RIGHT_PAREN)
            error();
        else {
            lex();
            statement();
            }
        }
    }
}

/* forstmt
 Parses strings in the language generated by the rule:
 <forstmt> -> for '(' [<expression>] ';' [<expression>] ';' [<expression>] ')' <statement>
 <block> --> '{' {<statement>} '}'
 */

if (nextToken != FOR_CODE)
        error();
    else {
    lex();
        if (nextToekn != LEFT_PAREN)
        error();
        else {
            lex();
            expression();
        if (nextToken != SEMICOLON)
            error();
        else {
            lex();
            expression();
            }
            if (nextToken != SEMICOLON)
            error();
        else {
            lex();
            expression();
        }
        if (nextToekn != RIGHT_PAREN)
            error();
        else {
            lex();
            statement();
    }
}

void error(){
    
}